<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Tema 22: Algoritmos sobre grafos</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="estilo.css">
</head>
<body>
<header>
<h1 class="title">Tema 22: Algoritmos sobre grafos</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#el-tad-de-los-grafos"><span class="toc-section-number">1</span> El TAD de los grafos</a><ul>
<li><a href="#definiciones-y-terminología-sobre-grafos"><span class="toc-section-number">1.1</span> Definiciones y terminología sobre grafos</a></li>
<li><a href="#signatura-del-tad-de-los-grafos"><span class="toc-section-number">1.2</span> Signatura del TAD de los grafos</a></li>
<li><a href="#implementación-de-los-grafos-como-vectores-de-adyacencia"><span class="toc-section-number">1.3</span> Implementación de los grafos como vectores de adyacencia</a></li>
<li><a href="#implementación-de-los-grafos-como-matrices-de-adyacencia"><span class="toc-section-number">1.4</span> Implementación de los grafos como matrices de adyacencia</a></li>
</ul></li>
<li><a href="#recorridos-en-profundidad-y-en-anchura"><span class="toc-section-number">2</span> Recorridos en profundidad y en anchura</a><ul>
<li><a href="#recorrido-en-profundidad"><span class="toc-section-number">2.1</span> Recorrido en profundidad</a></li>
<li><a href="#recorrido-en-anchura"><span class="toc-section-number">2.2</span> Recorrido en anchura</a></li>
</ul></li>
<li><a href="#árboles-de-expansión-mínimos"><span class="toc-section-number">3</span> Árboles de expansión mínimos</a><ul>
<li><a href="#el-algoritmo-de-kruskal"><span class="toc-section-number">3.1</span> El algoritmo de Kruskal</a></li>
<li><a href="#el-algoritmo-de-prim"><span class="toc-section-number">3.2</span> El algoritmo de Prim</a></li>
</ul></li>
</ul>
</nav>
<h1 id="el-tad-de-los-grafos"><span class="header-section-number">1</span> El TAD de los grafos</h1>
<h2 id="definiciones-y-terminología-sobre-grafos"><span class="header-section-number">1.1</span> Definiciones y terminología sobre grafos</h2>
<ul>
<li><p>Un <em>grafo G</em> es un par <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28V%2CA%29" alt="(V,A)" title="(V,A)" /> donde <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=V" alt="V" title="V" /> es el conjunto de los <em>vértices</em> (o nodos) y <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" /> el de las <em>aristas</em>.</p></li>
<li><p>Una <em>arista</em> del grafo es un par de vértices.</p></li>
<li><p>Un <em>arco</em> es una arista dirigida.</p></li>
<li><p><em>|V|</em> es el número de vértices.</p></li>
<li><p><em>|A|</em> es el número de aristas.</p></li>
<li><p>Un vértice <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" /> es <em>adjacente</em> a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v%27" alt="v&#39;" title="v&#39;" /> si <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=vv%27" alt="vv&#39;" title="vv&#39;" /> es una arista del grafo.</p></li>
<li><p>Un <em>grafo ponderado</em> es un grafo cuyas aristas tienen un peso.</p></li>
</ul>
<h2 id="signatura-del-tad-de-los-grafos"><span class="header-section-number">1.2</span> Signatura del TAD de los grafos</h2>
<p><strong>Signatura del TAD de los grafos</strong></p>
<pre class="sesion"><code>creaGrafo   :: (Ix v,Num p) =&gt; Orientacion -&gt; (v,v) -&gt; [(v,v,p)] -&gt; 
                               Grafo v p
dirigido    :: (Ix v,Num p) =&gt; (Grafo v p) -&gt; Bool
adyacentes  :: (Ix v,Num p) =&gt; (Grafo v p) -&gt; v -&gt; [v]
nodos       :: (Ix v,Num p) =&gt; (Grafo v p) -&gt; [v]
aristas     :: (Ix v,Num p) =&gt; (Grafo v p) -&gt; [(v,v,p)]
aristaEn    :: (Ix v,Num p) =&gt; (Grafo v p) -&gt; (v,v) -&gt; Bool
peso        :: (Ix v,Num p) =&gt; v -&gt; v -&gt; (Grafo v p) -&gt; p</code></pre>
<p><strong>Descripción de la signatura del TAD de grafos</strong></p>
<ul>
<li><p><code>(creaGrafo o cs as)</code> es un grafo (dirigido o no, según el valor de o), con el par de cotas cs y listas de aristas as (cada arista es un trío formado por los dos vértices y su peso). Ver un ejemplo en la siguiente transparencia.</p></li>
<li><p><code>(dirigido g)</code> se verifica si <code>g</code> es dirigido.</p></li>
<li><p><code>(nodos g)</code> es la lista de todos los nodos del grafo <code>g</code>.</p></li>
<li><p><code>(aristas g)</code> es la lista de las aristas del grafo <code>g</code>.</p></li>
<li><p><code>(adyacentes g v)</code> es la lista de los vértices adyacentes al nodo <code>v</code> en el grafo <code>g</code>.</p></li>
<li><p><code>(aristaEn g a)</code> se verifica si <code>a</code> es una arista del grafo <code>g</code>.</p></li>
<li><p><code>(peso v1 v2 g)</code> es el peso de la arista que une los vértices <code>v1</code> y <code>v2</code> en el grafo <code>g</code>.</p></li>
</ul>
<p><strong>Ejemplo de creación de grafos.</strong></p>
<pre class="sesion"><code>creaGrafo ND (1,5) [(1,2,12),(1,3,34),(1,5,78),
                    (2,4,55),(2,5,32),
                    (3,4,61),(3,5,44),
                    (4,5,93)]</code></pre>
<p>crea el grafo</p>
<pre class="sesion"><code>       12
  1 -------- 2
  | \78     /|
  |  \   32/ |
  |   \   /  |
34|     5    |55
  |   /   \  |
  |  /44   \ |
  | /     93\|
  3 -------- 4
       61</code></pre>
<h2 id="implementación-de-los-grafos-como-vectores-de-adyacencia"><span class="header-section-number">1.3</span> Implementación de los grafos como vectores de adyacencia</h2>
<ul>
<li>Cabecera del módulo:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">GrafoConVectorDeAdyacencia</span> 
    (<span class="dt">Orientacion</span> (<span class="fu">..</span>),
     <span class="dt">Grafo</span>,
     creaGrafo,  <span class="co">-- (Ix v,Num p) =&gt; Orientacion -&gt; (v,v) -&gt; [(v,v,p)] -&gt; </span>
                 <span class="co">--                 Grafo v p</span>
     dirigido,   <span class="co">-- (Ix v,Num p) =&gt; (Grafo v p) -&gt; Bool</span>
     adyacentes, <span class="co">-- (Ix v,Num p) =&gt; (Grafo v p) -&gt; v -&gt; [v]</span>
     nodos,      <span class="co">-- (Ix v,Num p) =&gt; (Grafo v p) -&gt; [v]</span>
     aristas,    <span class="co">-- (Ix v,Num p) =&gt; (Grafo v p) -&gt; [(v,v,p)]</span>
     aristaEn,   <span class="co">-- (Ix v,Num p) =&gt; (Grafo v p) -&gt; (v,v) -&gt; Bool</span>
     peso        <span class="co">-- (Ix v,Num p) =&gt; v -&gt; v -&gt; (Grafo v p) -&gt; p</span>
    ) <span class="kw">where</span></code></pre></div>
<ul>
<li>Librerías auxiliares.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Array</span></code></pre></div>
<ul>
<li><code>Orientacion</code> es <code>D</code> (dirigida) ó <code>ND</code> (no dirigida).</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Orientacion</span> <span class="fu">=</span> <span class="dt">D</span> <span class="fu">|</span> <span class="dt">ND</span>
                   <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<ul>
<li><code>(Grafo v p)</code> es un grafo con vértices de tipo <code>v</code> y pesos de tipo <code>p</code>.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Grafo</span> v p <span class="fu">=</span> <span class="dt">G</span> <span class="dt">Orientacion</span> (<span class="dt">Array</span> v [(v,p)])
                 <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<ul>
<li><code>(creaGrafo o cs as)</code> es un grafo (dirigido o no según el valor de <code>o</code>), con el par de cotas <code>cs</code> y listas de aristas <code>as</code> (cada arista es un trío formado por los dos vértices y su peso). Ver un ejemplo a continuación.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">creaGrafo ::</span> (<span class="dt">Ix</span> v, <span class="dt">Num</span> p) <span class="ot">=&gt;</span> 
             <span class="dt">Orientacion</span> <span class="ot">-&gt;</span> (v,v) <span class="ot">-&gt;</span> [(v,v,p)] <span class="ot">-&gt;</span> <span class="dt">Grafo</span> v p
creaGrafo o cs vs <span class="fu">=</span>
    <span class="dt">G</span> o (accumArray 
         (\xs x <span class="ot">-&gt;</span> xs<span class="fu">++</span>[x]) [] cs 
         ((<span class="kw">if</span> o <span class="fu">==</span> <span class="dt">D</span> <span class="kw">then</span> []
           <span class="kw">else</span> [(x2,(x1,p))<span class="fu">|</span>(x1,x2,p) <span class="ot">&lt;-</span> vs, x1 <span class="fu">/=</span> x2]) <span class="fu">++</span>
          [(x1,(x2,p)) <span class="fu">|</span> (x1,x2,p) <span class="ot">&lt;-</span> vs]))</code></pre></div>
<ul>
<li><code>ejGrafoND</code> es el grafo</li>
</ul>
<pre class="sesion"><code>       12
  1 -------- 2
  | \78     /|
  |  \   32/ |
  |   \   /  |
34|     5    |55
  |   /   \  |
  |  /44   \ |
  | /     93\|
  3 -------- 4
       61</code></pre>
<pre class="sesion"><code>ghci&gt; ejGrafoND
G ND array (1,5) [(1,[(2,12),(3,34),(5,78)]),
                  (2,[(1,12),(4,55),(5,32)]),
                  (3,[(1,34),(4,61),(5,44)]),
                  (4,[(2,55),(3,61),(5,93)]),
                  (5,[(1,78),(2,32),(3,44),(4,93)])])</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ejGrafoND <span class="fu">=</span> creaGrafo <span class="dt">ND</span> (<span class="dv">1</span>,<span class="dv">5</span>) [(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">12</span>),(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">34</span>),(<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">78</span>),
                                (<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">55</span>),(<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">32</span>),
                                (<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">61</span>),(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">44</span>),
                                (<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">93</span>)]</code></pre></div>
<ul>
<li><code>ejGrafoD</code> es el mismo grafo que ejGrafoND pero orientando las aristas de menor a mayor. Por ejemplo,</li>
</ul>
<pre class="sesion"><code>ghci&gt; ejGrafoD
G D array (1,5) [(1,[(2,12),(3,34),(5,78)]),
                 (2,[(4,55),(5,32)]),
                 (3,[(4,61),(5,44)]),
                 (4,[(5,93)]),
                 (5,[])])</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ejGrafoD <span class="fu">=</span> creaGrafo <span class="dt">D</span> (<span class="dv">1</span>,<span class="dv">5</span>) [(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">12</span>),(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">34</span>),(<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">78</span>),
                              (<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">55</span>),(<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">32</span>),
                              (<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">61</span>),(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">44</span>),
                              (<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">93</span>)]</code></pre></div>
<ul>
<li><code>(dirigido g)</code> se verifica si <code>g</code> es dirigido. Por ejemplo,</li>
</ul>
<pre class="sesion"><code>dirigido ejGrafoD   ==  True
dirigido ejGrafoND  ==  False</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">dirigido ::</span> (<span class="dt">Ix</span> v,<span class="dt">Num</span> p) <span class="ot">=&gt;</span> (<span class="dt">Grafo</span> v p) <span class="ot">-&gt;</span> <span class="dt">Bool</span>
dirigido (<span class="dt">G</span> o _) <span class="fu">=</span> o <span class="fu">==</span> <span class="dt">D</span></code></pre></div>
<ul>
<li><code>(adyacentes g v)</code> es la lista de los vértices adyacentes al nodo <code>v</code> en el grafo <code>g</code>. Por ejemplo,</li>
</ul>
<pre class="sesion"><code>adyacentes ejGrafoND 4  ==  [2,3,5]
adyacentes ejGrafoD  4  ==  [5]</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">adyacentes ::</span> (<span class="dt">Ix</span> v,<span class="dt">Num</span> p) <span class="ot">=&gt;</span> (<span class="dt">Grafo</span> v p) <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> [v]
adyacentes (<span class="dt">G</span> _ g) v <span class="fu">=</span> map fst (g<span class="fu">!</span>v)</code></pre></div>
<ul>
<li><code>(nodos g)</code> es la lista de todos los nodos del grafo <code>g</code>. Por ejemplo,</li>
</ul>
<pre class="sesion"><code>nodos ejGrafoND  ==  [1,2,3,4,5]
nodos ejGrafoD   ==  [1,2,3,4,5]</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">nodos ::</span> (<span class="dt">Ix</span> v,<span class="dt">Num</span> p) <span class="ot">=&gt;</span> (<span class="dt">Grafo</span> v p) <span class="ot">-&gt;</span> [v]
nodos (<span class="dt">G</span> _ g) <span class="fu">=</span> indices g</code></pre></div>
<ul>
<li><code>(peso v1 v2 g)</code> es el peso de la arista que une los vértices <code>v1</code> y <code>v2</code> en el grafo <code>g</code>. Por ejemplo,</li>
</ul>
<pre class="sesion"><code>peso 1 5 ejGrafoND  ==  78
peso 1 5 ejGrafoD   ==  78</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">peso ::</span> (<span class="dt">Ix</span> v,<span class="dt">Num</span> p) <span class="ot">=&gt;</span> v <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> (<span class="dt">Grafo</span> v p) <span class="ot">-&gt;</span> p
peso x y (<span class="dt">G</span> _ g) <span class="fu">=</span> head [c <span class="fu">|</span> (a,c) <span class="ot">&lt;-</span> g<span class="fu">!</span>x , a <span class="fu">==</span> y]</code></pre></div>
<ul>
<li><code>(aristaEn g a)</code> se verifica si <code>a</code> es una arista del grafo <code>g</code>. Por ejemplo,</li>
</ul>
<pre class="sesion"><code>aristaEn ejGrafoND (5,1)  ==  True
aristaEn ejGrafoND (4,1)  ==  False
aristaEn ejGrafoD  (5,1)  ==  False
aristaEn ejGrafoD  (1,5)  ==  True</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">aristaEn ::</span> (<span class="dt">Ix</span> v,<span class="dt">Num</span> p) <span class="ot">=&gt;</span> (<span class="dt">Grafo</span> v p) <span class="ot">-&gt;</span> (v,v) <span class="ot">-&gt;</span> <span class="dt">Bool</span>
aristaEn g (x,y) <span class="fu">=</span> y <span class="ot">`elem`</span> adyacentes g x</code></pre></div>
<ul>
<li><code>(aristas g)</code> es la lista de las aristas del grafo <code>g</code>. Por ejemplo,</li>
</ul>
<pre class="sesion"><code>ghci&gt; aristas ejGrafoND
[(1,2,12),(1,3,34),(1,5,78),(2,1,12),(2,4,55),(2,5,32),
 (3,1,34),(3,4,61),(3,5,44),(4,2,55),(4,3,61),(4,5,93),
 (5,1,78),(5,2,32),(5,3,44),(5,4,93)]
ghci&gt; aristas ejGrafoD
[(1,2,12),(1,3,34),(1,5,78),(2,4,55),(2,5,32),(3,4,61),
 (3,5,44),(4,5,93)] </code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">aristas ::</span> (<span class="dt">Ix</span> v,<span class="dt">Num</span> p) <span class="ot">=&gt;</span> (<span class="dt">Grafo</span> v p) <span class="ot">-&gt;</span> [(v,v,p)]
aristas (<span class="dt">G</span> o g) <span class="fu">=</span> 
    [(v1,v2,w) <span class="fu">|</span> v1 <span class="ot">&lt;-</span> nodos (<span class="dt">G</span> o g) , (v2,w) <span class="ot">&lt;-</span> g<span class="fu">!</span>v1] </code></pre></div>
<h2 id="implementación-de-los-grafos-como-matrices-de-adyacencia"><span class="header-section-number">1.4</span> Implementación de los grafos como matrices de adyacencia</h2>
<ul>
<li>Cabecera del módulo.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">GrafoConMatrizDeAdyacencia</span> 
    (<span class="dt">Orientacion</span> (<span class="fu">..</span>),
     <span class="dt">Grafo</span>,
     creaGrafo,  <span class="co">-- (Ix v,Num p) =&gt; Orientacion -&gt; (v,v) -&gt; [(v,v,p)] -&gt; </span>
                 <span class="co">--                 Grafo v p</span>
     dirigido,   <span class="co">-- (Ix v,Num p) =&gt; (Grafo v p) -&gt; Bool</span>
     adyacentes, <span class="co">-- (Ix v,Num p) =&gt; (Grafo v p) -&gt; v -&gt; [v]</span>
     nodos,      <span class="co">-- (Ix v,Num p) =&gt; (Grafo v p) -&gt; [v]</span>
     aristas,    <span class="co">-- (Ix v,Num p) =&gt; (Grafo v p) -&gt; [(v,v,p)]</span>
     aristaEn,   <span class="co">-- (Ix v,Num p) =&gt; (Grafo v p) -&gt; (v,v) -&gt; Bool</span>
     peso        <span class="co">-- (Ix v,Num p) =&gt; v -&gt; v -&gt; (Grafo v p) -&gt; p</span>
    ) <span class="kw">where</span></code></pre></div>
<ul>
<li>Librerías auxiliares</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Array</span></code></pre></div>
<ul>
<li><code>Orientacion</code> es <code>D</code> (dirigida) ó <code>ND</code> (no dirigida).</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Orientacion</span> <span class="fu">=</span> <span class="dt">D</span> <span class="fu">|</span> <span class="dt">ND</span>
                   <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<ul>
<li><code>(Grafo v p)</code> es un grafo con vértices de tipo <code>v</code> y pesos de tipo <code>p</code>.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Grafo</span> v p <span class="fu">=</span> <span class="dt">G</span> <span class="dt">Orientacion</span> (<span class="dt">Array</span> (v,v) (<span class="dt">Maybe</span> p))
                 <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<ul>
<li><code>(creaGrafo o cs as)</code> es un grafo (dirigido o no, según el valor de <code>o</code>), con el par de cotas <code>cs</code> y listas de aristas <code>as</code> (cada arista es un trío formado por los dos vértices y su peso). Ver un ejemplo a continuación.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">creaGrafo ::</span> (<span class="dt">Ix</span> v, <span class="dt">Num</span> p) <span class="ot">=&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> (v,v) <span class="ot">-&gt;</span> [(v,v,p)] 
                              <span class="ot">-&gt;</span> <span class="dt">Grafo</span> v p
creaGrafo o cs<span class="fu">@</span>(l,u) as 
    <span class="fu">=</span> <span class="dt">G</span> o (matrizVacia <span class="fu">//</span> 
            ([((x1,x2),<span class="dt">Just</span> w) <span class="fu">|</span> (x1,x2,w) <span class="ot">&lt;-</span> as] <span class="fu">++</span>
             <span class="kw">if</span> o <span class="fu">==</span> <span class="dt">D</span> <span class="kw">then</span> []
             <span class="kw">else</span> [((x2,x1),<span class="dt">Just</span> w) <span class="fu">|</span> (x1,x2,w) <span class="ot">&lt;-</span> as, x1 <span class="fu">/=</span> x2]))
      <span class="kw">where</span>
      matrizVacia <span class="fu">=</span> array ((l,l),(u,u)) 
                          [((x1,x2),<span class="dt">Nothing</span>) <span class="fu">|</span> x1 <span class="ot">&lt;-</span> range cs, 
                                               x2 <span class="ot">&lt;-</span> range cs]</code></pre></div>
<ul>
<li><code>ejGrafoND</code> es el grafo</li>
</ul>
<pre class="sesion"><code>       12
  1 -------- 2
  | \78     /|
  |  \   32/ |
  |   \   /  |
34|     5    |55
  |   /   \  |
  |  /44   \ |
  | /     93\|
  3 -------- 4
       61</code></pre>
<pre class="sesion"><code>ghci&gt; ejGrafoND
G ND array ((1,1),(5,5)) 
           [((1,1),Nothing),((1,2),Just 12),((1,3),Just 34),
            ((1,4),Nothing),((1,5),Just 78),((2,1),Just 12),
            ((2,2),Nothing),((2,3),Nothing),((2,4),Just 55),
            ((2,5),Just 32),((3,1),Just 34),((3,2),Nothing),
            ((3,3),Nothing),((3,4),Just 61),((3,5),Just 44),
            ((4,1),Nothing),((4,2),Just 55),((4,3),Just 61),
            ((4,4),Nothing),((4,5),Just 93),((5,1),Just 78),
            ((5,2),Just 32),((5,3),Just 44),((5,4),Just 93),
            ((5,5),Nothing)]</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ejGrafoND <span class="fu">=</span> creaGrafo <span class="dt">ND</span> (<span class="dv">1</span>,<span class="dv">5</span>) [(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">12</span>),(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">34</span>),(<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">78</span>),
                                (<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">55</span>),(<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">32</span>),
                                (<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">61</span>),(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">44</span>),
                                (<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">93</span>)]</code></pre></div>
<ul>
<li><code>ejGrafoD</code> es el mismo grafo que ejGrafoND pero orientando las aristas de menor a mayor. Por ejemplo,</li>
</ul>
<pre class="sesion"><code>ghci&gt; ejGrafoD
G D (array ((1,1),(5,5)) 
           [((1,1),Nothing),((1,2),Just 12),((1,3),Just 34),
            ((1,4),Nothing),((1,5),Just 78),((2,1),Nothing),
            ((2,2),Nothing),((2,3),Nothing),((2,4),Just 55),
            ((2,5),Just 32),((3,1),Nothing),((3,2),Nothing),
            ((3,3),Nothing),((3,4),Just 61),((3,5),Just 44),
            ((4,1),Nothing),((4,2),Nothing),((4,3),Nothing),
            ((4,4),Nothing),((4,5),Just 93),((5,1),Nothing),
            ((5,2),Nothing),((5,3),Nothing),((5,4),Nothing),
            ((5,5),Nothing)])</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ejGrafoD <span class="fu">=</span> creaGrafo <span class="dt">D</span> (<span class="dv">1</span>,<span class="dv">5</span>) [(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">12</span>),(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">34</span>),(<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">78</span>),
                              (<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">55</span>),(<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">32</span>),
                              (<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">61</span>),(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">44</span>),
                              (<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">93</span>)]</code></pre></div>
<ul>
<li><code>(dirigido g)</code> se verifica si <code>g</code> es dirigido. Por ejemplo,</li>
</ul>
<pre class="sesion"><code>dirigido ejGrafoD   ==  True
dirigido ejGrafoND  ==  False</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">dirigido ::</span> (<span class="dt">Ix</span> v,<span class="dt">Num</span> p) <span class="ot">=&gt;</span> (<span class="dt">Grafo</span> v p) <span class="ot">-&gt;</span> <span class="dt">Bool</span>
dirigido (<span class="dt">G</span> o _) <span class="fu">=</span> o <span class="fu">==</span> <span class="dt">D</span></code></pre></div>
<ul>
<li><code>(adyacentes g v)</code> es la lista de los vértices adyacentes al nodo <code>v</code> en el grafo <code>g</code>. Por ejemplo,</li>
</ul>
<pre class="sesion"><code>adyacentes ejGrafoND 4  ==  [2,3,5]
adyacentes ejGrafoD  4  ==  [5]</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">adyacentes ::</span> (<span class="dt">Ix</span> v,<span class="dt">Num</span> p) <span class="ot">=&gt;</span> (<span class="dt">Grafo</span> v p) <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> [v]
adyacentes (<span class="dt">G</span> o g) v <span class="fu">=</span> 
    [v&#39; <span class="fu">|</span> v&#39; <span class="ot">&lt;-</span> nodos (<span class="dt">G</span> o g), (g<span class="fu">!</span>(v,v&#39;)) <span class="fu">/=</span> <span class="dt">Nothing</span>]</code></pre></div>
<ul>
<li><code>(nodos g)</code> es la lista de todos los nodos del grafo <code>g</code>. Por ejemplo,</li>
</ul>
<pre class="sesion"><code>nodos ejGrafoND  ==  [1,2,3,4,5]
nodos ejGrafoD   ==  [1,2,3,4,5]</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">nodos ::</span> (<span class="dt">Ix</span> v,<span class="dt">Num</span> p) <span class="ot">=&gt;</span> (<span class="dt">Grafo</span> v p) <span class="ot">-&gt;</span> [v]
nodos (<span class="dt">G</span> _ g) <span class="fu">=</span> range (l,u) 
    <span class="kw">where</span> ((l,_),(u,_)) <span class="fu">=</span> bounds g</code></pre></div>
<ul>
<li><code>(peso v1 v2 g)</code> es el peso de la arista que une los vértices <code>v1</code> y <code>v2</code> en el grafo <code>g</code>. Por ejemplo,</li>
</ul>
<pre class="sesion"><code>peso 1 5 ejGrafoND  ==  78
peso 1 5 ejGrafoD   ==  78</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">peso ::</span> (<span class="dt">Ix</span> v,<span class="dt">Num</span> p) <span class="ot">=&gt;</span> v <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> (<span class="dt">Grafo</span> v p) <span class="ot">-&gt;</span> p
peso x y (<span class="dt">G</span> _ g)  <span class="fu">=</span> w <span class="kw">where</span> (<span class="dt">Just</span> w) <span class="fu">=</span> g<span class="fu">!</span>(x,y)</code></pre></div>
<ul>
<li><code>(aristaEn g a)</code> se verifica si <code>a</code> es una arista del grafo <code>g</code>. Por ejemplo,</li>
</ul>
<pre class="sesion"><code>aristaEn ejGrafoND (5,1)  ==  True
aristaEn ejGrafoND (4,1)  ==  False</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">aristaEn ::</span> (<span class="dt">Ix</span> v,<span class="dt">Num</span> p) <span class="ot">=&gt;</span> (<span class="dt">Grafo</span> v p) <span class="ot">-&gt;</span> (v,v) <span class="ot">-&gt;</span> <span class="dt">Bool</span>
aristaEn (<span class="dt">G</span> _o g) (x,y)<span class="fu">=</span> (g<span class="fu">!</span>(x,y)) <span class="fu">/=</span> <span class="dt">Nothing</span></code></pre></div>
<ul>
<li><code>(aristas g)</code> es la lista de las aristas del grafo <code>g</code>. Por ejemplo,</li>
</ul>
<pre class="sesion"><code>ghci&gt; aristas ejGrafoD
[(1,2,12),(1,3,34),(1,5,78),(2,4,55),(2,5,32),(3,4,61),
 (3,5,44),(4,5,93)] 
ghci&gt; aristas ejGrafoND
[(1,2,12),(1,3,34),(1,5,78),(2,1,12),(2,4,55),(2,5,32),
 (3,1,34),(3,4,61),(3,5,44),(4,2,55),(4,3,61),(4,5,93),
 (5,1,78),(5,2,32),(5,3,44),(5,4,93)]</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">aristas ::</span> (<span class="dt">Ix</span> v,<span class="dt">Num</span> p) <span class="ot">=&gt;</span> (<span class="dt">Grafo</span> v p) <span class="ot">-&gt;</span> [(v,v,p)]
aristas g<span class="fu">@</span>(<span class="dt">G</span> o e) <span class="fu">=</span> [(v1,v2,extrae(e<span class="fu">!</span>(v1,v2))) 
                     <span class="fu">|</span> v1 <span class="ot">&lt;-</span> nodos g, 
                       v2 <span class="ot">&lt;-</span> nodos g,
                       aristaEn g (v1,v2)]
    <span class="kw">where</span> extrae (<span class="dt">Just</span> w) <span class="fu">=</span> w</code></pre></div>
<h1 id="recorridos-en-profundidad-y-en-anchura"><span class="header-section-number">2</span> Recorridos en profundidad y en anchura</h1>
<h2 id="recorrido-en-profundidad"><span class="header-section-number">2.1</span> Recorrido en profundidad</h2>
<ul>
<li>Importaciones de librerías auxiliares.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Nota: Elegir una implementación de los grafos.</span>
<span class="kw">import </span><span class="dt">GrafoConVectorDeAdyacencia</span>
<span class="co">-- import GrafoConMatrizDeAdyacencia</span></code></pre></div>
<ul>
<li>En los ejemplos se usará el grafo <code>g</code></li>
</ul>
<pre class="sesion"><code>+---&gt; 2 &lt;---+
|           |
|           |
1 --&gt; 3 --&gt; 6 --&gt; 5
|                 |
|                 |
+---&gt; 4 &lt;---------+</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">g <span class="fu">=</span> creaGrafo <span class="dt">D</span> (<span class="dv">1</span>,<span class="dv">6</span>) 
              [(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">0</span>),(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">0</span>),(<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">0</span>),(<span class="dv">3</span>,<span class="dv">6</span>,<span class="dv">0</span>),
               (<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">0</span>),(<span class="dv">6</span>,<span class="dv">2</span>,<span class="dv">0</span>),(<span class="dv">6</span>,<span class="dv">5</span>,<span class="dv">0</span>)]</code></pre></div>
<p><strong>Procedimiento elemental de recorrido en profundidad</strong></p>
<ul>
<li><code>(recorridoEnProfundidad i g)</code> es el recorrido en profundidad del grafo <code>g</code> desde el vértice <code>i</code>. Por ejemplo,</li>
</ul>
<pre class="sesion"><code>recorridoEnProfundidad 1 g  ==  [1,2,3,6,5,4]</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">recorridoEnProfundidad i g <span class="fu">=</span> rp [i] []
    <span class="kw">where</span> 
      rp [] vis    <span class="fu">=</span> vis
      rp (c<span class="fu">:</span>cs) vis 
          <span class="fu">|</span> c <span class="ot">`elem`</span> vis <span class="fu">=</span> rp cs vis
          <span class="fu">|</span> otherwise    <span class="fu">=</span> rp ((adyacentes g c)<span class="fu">++</span>cs) 
                              (vis<span class="fu">++</span>[c])</code></pre></div>
<ul>
<li>Traza del cálculo de <code>(recorridoEnProfundidad 1 g)</code></li>
</ul>
<pre class="sesion"><code>recorridoEnProfundidad 1 g
= rp [1]     []
= rp [2,3,4] [1]
= rp [3,4]   [1,2]
= rp [6,4]   [1,2,3]
= rp [2,5,4] [1,2,3,6]
= rp [5,4]   [1,2,3,6]
= rp [4,4]   [1,2,3,6,5]
= rp [4]     [1,2,3,6,5,4]
= rp []      [1,2,3,6,5,4]
= [1,2,3,6,5,4]</code></pre>
<p><strong>Recorrido en profundidad con acumuladores</strong></p>
<ul>
<li><code>(recorridoEnProfundidad' i g)</code> es el recorrido en profundidad del grafo, usando la lista de los visitados como acumulador. Por ejemplo,</li>
</ul>
<pre class="sesion"><code>recorridoEnProfundidad&#39; 1 g  ==  [1,2,3,6,5,4]</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">recorridoEnProfundidad&#39; i g <span class="fu">=</span> reverse (rp [i] [])
    <span class="kw">where</span>
      rp [] vis     <span class="fu">=</span> vis
      rp (c<span class="fu">:</span>cs) vis 
          <span class="fu">|</span> c <span class="ot">`elem`</span> vis <span class="fu">=</span> rp cs vis
          <span class="fu">|</span> otherwise    <span class="fu">=</span> rp ((adyacentes g c)<span class="fu">++</span>cs) 
                              (c<span class="fu">:</span>vis)</code></pre></div>
<ul>
<li>Traza del cálculo de <code>(recorridoEnProfundidad' 1 g)</code></li>
</ul>
<pre class="sesion"><code>recorridoEnProfundidad&#39; 1 g
= reverse (rp [1]     [])
= reverse (rp [2,3,4] [1])
= reverse (rp [3,4]   [2,1])
= reverse (rp [6,4]   [3,2,1])
= reverse (rp [2,5,4] [6,3,2,1])
= reverse (rp [5,4]   [6,3,2,1])
= reverse (rp [4,4]   [5,6,3,2,1])
= reverse (rp [4]     [4,5,6,3,2,1])
= reverse (rp []      [4,5,6,3,2,1])
= reverse [4,5,6,3,2,1]
= [1,2,3,6,5,4]</code></pre>
<h2 id="recorrido-en-anchura"><span class="header-section-number">2.2</span> Recorrido en anchura</h2>
<ul>
<li>Importaciones de librerías auxiliares.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Nota: Elegir una implementación de los grafos.</span>
<span class="kw">import </span><span class="dt">GrafoConVectorDeAdyacencia</span>
<span class="co">-- import GrafoConMatrizDeAdyacencia</span></code></pre></div>
<p><strong>Procedimiento elemental de recorrido en anchura</strong></p>
<ul>
<li><code>(recorridoEnAnchura i g)</code> es el recorrido en anchura del grafo <code>g</code> desde el vértice <code>i</code>. Por ejemplo,</li>
</ul>
<pre class="sesion"><code>recorridoEnAnchura 1 g  ==  [1,4,3,2,6,5]</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">recorridoEnAnchura i g <span class="fu">=</span> reverse (ra [i] [])
    <span class="kw">where</span> 
      ra [] vis    <span class="fu">=</span> vis
      ra (c<span class="fu">:</span>cs) vis 
          <span class="fu">|</span> c <span class="ot">`elem`</span> vis <span class="fu">=</span> ra cs vis
          <span class="fu">|</span> otherwise    <span class="fu">=</span> ra (cs <span class="fu">++</span> adyacentes g c) 
                              (c<span class="fu">:</span>vis)</code></pre></div>
<ul>
<li>Traza del cálculo de <code>(recorridoEnAnchura 1 g)</code></li>
</ul>
<pre class="sesion"><code>RecorridoEnAnchura 1 g
= ra [1]     []
= ra [2,3,4] [1]
= ra [3,4]   [2,1]
= ra [4,6]   [3,2,1]
= ra [6]     [4,3,2,1]
= ra [2,5]   [6,4,3,2,1]
= ra [5]     [6,4,3,2,1]
= ra [4]     [5,6,4,3,2,1]
= ra []      [5,6,4,3,2,1]
= [1,2,3,4,6,5]</code></pre>
<h1 id="árboles-de-expansión-mínimos"><span class="header-section-number">3</span> Árboles de expansión mínimos</h1>
<ul>
<li><p>Sea G = (V,A) un grafo conexo no orientado en el que cada arista tiene un peso no negativo. Un <em>árbol de expansión mínimo</em> de G es un subgrafo G' = (V,A') que conecta todos los vértices de G y tal que la suma de sus pesos es mínima.</p></li>
<li><p><em>Aplicación:</em> Si los vértices representan ciudades y el coste de una arista {a,b} es el construir una carretera de a a b, entonces un árbol de expansión mínimo representa el modo de enlazar todas las ciudades mediante una red de carreteras de coste mínimo.</p></li>
<li>Terminología de algoritmos voraces: Sea G = (V,A) un grafo y T un conjunto de aristas de G.
<ul>
<li>T es una <em>solución</em> si es un grafo de expansión.</li>
<li>T es <em>completable</em> si no tiene ciclos.</li>
<li>T es <em>prometedor</em> si es completable y puede ser completado hasta llegar a una solución óptima.</li>
<li>Una arista <em>toca</em> un conjunto de vértices B si exactamente uno de sus extremos pertenece a B.</li>
</ul></li>
<li><p><em>Teorema:</em> Sea G = (V,A) un grafo conexo no orientado cuyas aristas tienen un peso asociado. Sea B un subjconjunto propio del conjunto de vértices V y T un conjunto prometedor de aristas tal que ninguna arista de T toca a B. Sea e una arista de peso mínimo de entre todas las que tocan a B. Entonces, (T ∪ {e}) es prometedor.</p></li>
</ul>
<h2 id="el-algoritmo-de-kruskal"><span class="header-section-number">3.1</span> El algoritmo de Kruskal</h2>
<p>Para los ejemplos se considera el siguiente grafo:</p>
<pre class="sesion"><code>     1       2 
 1 ----- 2 ----- 3
 |      /|      /| 
 |     / |     / | 
 |    /  |    /  | 
4|   /6  |4  /5  |6
 |  /    |  /    | 
 | /     | /     | 
 |/      |/      | 
 4 ----- 5 ----- 6
  \  3   |   8  /
   \     |     /
    \    |    /
    4\   |7  /3
      \  |  /
       \ | / 
        \|/
         7</code></pre>
<ul>
<li>Aplicación del algoritmo de Kruskal al grafo anterior:</li>
</ul>
<pre class="sesion"><code>Etapa Arista Componentes conexas
0            {1} {2} {3} {4} {5} {6} {7}
1     {1,2}  {1,2} {3} {4} {5} {6} {7}
2     {2,3}  {1,2,3} {4} {5} {6} {7}
3     {4,5}  {1,2,3} {4,5} {6} {7}
4     {6,7}  {1,2,3} {4,5} {6,7}
5     {1,4}  {1,2,3,4,5} {6,7}
6     {2,5}  arista rechazada
7     {4,7}  {1,2,3,4,5,6,7}</code></pre>
<ul>
<li>El árbol de expansión mínimo contiene las aristas no rechazadas:</li>
</ul>
<pre class="sesion"><code>{1,2}, {2,3}, {4,5}, {6,7}, {1,4} y {4,7}.                                 </code></pre>
<ul>
<li>Librerías auxiliares.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Nota: Seleccionar una implementación del TAD grafo.</span>
<span class="kw">import </span><span class="dt">GrafoConVectorDeAdyacencia</span>
<span class="co">-- import GrafoConMatrizDeAdyacencia</span>

<span class="co">-- Nota: Seleccionar una implementación del TAD tabla.</span>
<span class="co">-- import TablaConFunciones</span>
<span class="kw">import </span><span class="dt">TablaConListasDeAsociacion</span>
<span class="co">-- import TablaConMatrices</span>

<span class="kw">import </span><span class="dt">Data.List</span>
<span class="kw">import </span><span class="dt">Data.Ix</span></code></pre></div>
<ul>
<li>Grafos usados en los ejemplos.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">g1 ::</span> <span class="dt">Grafo</span> <span class="dt">Int</span> <span class="dt">Int</span>    
g1 <span class="fu">=</span> creaGrafo <span class="dt">D</span> (<span class="dv">1</span>,<span class="dv">5</span>) [(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">12</span>),(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">34</span>),(<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">78</span>),
                        (<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">55</span>),(<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">32</span>),
                        (<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">61</span>),(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">44</span>),
                        (<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">93</span>)]

<span class="ot">g2 ::</span> <span class="dt">Grafo</span> <span class="dt">Int</span> <span class="dt">Int</span>    
g2 <span class="fu">=</span> creaGrafo <span class="dt">D</span> (<span class="dv">1</span>,<span class="dv">5</span>) [(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">13</span>),(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">11</span>),(<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">78</span>),
                        (<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">12</span>),(<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">32</span>),
                        (<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">14</span>),(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">44</span>),
                        (<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">93</span>)]</code></pre></div>
<ul>
<li><code>(kruskal g)</code> es el árbol de expansión mínimo del grafo <code>g</code> calculado mediante el algoritmo de Kruskal. Por ejemplo,</li>
</ul>
<pre class="sesion"><code>kruskal g1  ==  [(55,2,4),(34,1,3),(32,2,5),(12,1,2)]
kruskal g2  ==  [(32,2,5),(13,1,2),(12,2,4),(11,1,3)]</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">kruskal ::</span> (<span class="dt">Ix</span> v, <span class="dt">Num</span> p, <span class="dt">Ord</span> p) <span class="ot">=&gt;</span> <span class="dt">Grafo</span> v p <span class="ot">-&gt;</span> [(p,v,v)]
kruskal g <span class="fu">=</span> kruskal&#39; cola                           <span class="co">-- Cola de prioridad</span>
                     (tabla [(x,x) <span class="fu">|</span> x <span class="ot">&lt;-</span> nodos g]) <span class="co">-- Tabla de raices</span>
                     []                             <span class="co">-- Árbol de expansión</span>
                     ((length (nodos g)) <span class="fu">-</span> <span class="dv">1</span>)       <span class="co">-- Aristas por</span>
                                                    <span class="co">-- colocar</span>
    <span class="kw">where</span> cola <span class="fu">=</span> sort [(p,x,y) <span class="fu">|</span> (x,y,p) <span class="ot">&lt;-</span> aristas g]

kruskal&#39; ((p,x,y)<span class="fu">:</span>as) t ae n 
    <span class="fu">|</span> n<span class="fu">==</span><span class="dv">0</span>        <span class="fu">=</span> ae
    <span class="fu">|</span> actualizado <span class="fu">=</span> kruskal&#39; as t&#39; ((p,x,y)<span class="fu">:</span>ae) (n<span class="fu">-</span><span class="dv">1</span>)
    <span class="fu">|</span> otherwise   <span class="fu">=</span> kruskal&#39; as t  ae           n
    <span class="kw">where</span> (actualizado,t&#39;) <span class="fu">=</span> buscaActualiza (x,y) t</code></pre></div>
<ul>
<li><code>(raiz t n)</code> es la raíz de <code>n</code> en la tabla <code>t</code>. Por ejemplo,</li>
</ul>
<pre class="sesion"><code>&gt; raiz (crea [(1,1),(3,1),(4,3),(5,4),(2,6),(6,6)]) 5  
1
&gt; raiz (crea [(1,1),(3,1),(4,3),(5,4),(2,6),(6,6)]) 2  
6</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">raiz::</span> <span class="dt">Eq</span> n <span class="ot">=&gt;</span> <span class="dt">Tabla</span> n n <span class="ot">-&gt;</span> n <span class="ot">-&gt;</span> n
raiz t x <span class="fu">|</span> v <span class="fu">==</span> x    <span class="fu">=</span> v
         <span class="fu">|</span> otherwise <span class="fu">=</span> raiz t v
         <span class="kw">where</span> v <span class="fu">=</span> valor t x</code></pre></div>
<ul>
<li><code>(buscaActualiza a t)</code> es el par formado por <code>False</code> y la tabla <code>t</code>, si los dos vértices de la arista <code>a</code> tienen la misma raíz en <code>t</code> y el par formado por <code>True</code> y la tabla obtenida añadiéndole a <code>t</code> la arista formada por el vértice de <code>a</code> de mayor raíz y la raíz del vértice de <code>a</code> de menor raíz. Por ejemplo,</li>
</ul>
<pre class="sesion"><code>ghci&gt; let t = crea [(1,1),(2,2),(3,1),(4,1)]
ghci&gt; buscaActualiza (2,3) t
(True,Tbl [(1,1),(2,1),(3,1),(4,1)])
ghci&gt; buscaActualiza (3,4) t
(False,Tbl [(1,1),(2,2),(3,1),(4,1)])</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">buscaActualiza ::</span> (<span class="dt">Eq</span> n, <span class="dt">Ord</span> n) <span class="ot">=&gt;</span> (n,n) <span class="ot">-&gt;</span> <span class="dt">Tabla</span> n n 
                                   <span class="ot">-&gt;</span> (<span class="dt">Bool</span>,<span class="dt">Tabla</span> n n)
buscaActualiza (x,y) t 
    <span class="fu">|</span> x&#39; <span class="fu">==</span> y&#39;  <span class="fu">=</span> (<span class="dt">False</span>, t) 
    <span class="fu">|</span> y&#39; <span class="fu">&lt;</span>  x&#39;  <span class="fu">=</span> (<span class="dt">True</span>, modifica (x,y&#39;) t)
    <span class="fu">|</span> otherwise <span class="fu">=</span> (<span class="dt">True</span>, modifica (y,x&#39;) t)
    <span class="kw">where</span> x&#39; <span class="fu">=</span> raiz t x 
          y&#39; <span class="fu">=</span> raiz t y</code></pre></div>
<h2 id="el-algoritmo-de-prim"><span class="header-section-number">3.2</span> El algoritmo de Prim</h2>
<ul>
<li><code>(prim g)</code> es el árbol de expansión mínimo del grafo <code>g</code> calculado mediante el algoritmo de Prim. Por ejemplo,</li>
</ul>
<pre class="sesion"><code>prim g1  ==  [(55,2,4),(34,1,3),(32,2,5),(12,1,2)]
prim g2  ==  [(32,2,5),(12,2,4),(13,1,2),(11,1,3)]</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prim ::</span> (<span class="dt">Ix</span> v, <span class="dt">Num</span> p, <span class="dt">Ord</span> p) <span class="ot">=&gt;</span> <span class="dt">Grafo</span> v p <span class="ot">-&gt;</span> [(p,v,v)]
prim g <span class="fu">=</span> prim&#39; [n]              <span class="co">-- Nodos colocados</span>
               ns               <span class="co">-- Nodos por colocar </span>
               []               <span class="co">-- Árbol de expansión</span>
               (aristas g)      <span class="co">-- Aristas del grafo</span>
         <span class="kw">where</span> (n<span class="fu">:</span>ns) <span class="fu">=</span> nodos g

prim&#39; t [] ae as <span class="fu">=</span> ae
prim&#39; t r  ae as <span class="fu">=</span> prim&#39; (v&#39;<span class="fu">:</span>t) (delete v&#39; r) (e<span class="fu">:</span>ae) as
    <span class="kw">where</span> e<span class="fu">@</span>(c,u&#39;, v&#39;) <span class="fu">=</span> minimum [(c,u,v)<span class="fu">|</span> (u,v,c) <span class="ot">&lt;-</span> as,
                                           elem u t, 
                                           elem v r]</code></pre></div>
<hr />
<div id="nav">
<p>
<strong>I1M2015</strong>: <a href="../index.php">Inicial</a> | <a href="../temas.php">Temas</a> | <a href="../ejercicios.php">Ejercicios</a> | <a href="../doc.php">Documentación</a> | <a href="../sistemas.php">Sistemas</a> | <a href="../examenes.php">Exámenes</a>
</p>
</div>
<hr />
<div id="foto">
<p><a href="http://www.us.es/"> <img src="sello-us.jpg"  
      alt="Universidad de Sevilla" wclassth="140" height="140" border="0"></a></p>
</div>
<div id="firma">
<p><a href="/~jalonso">José A. Alonso Jiménez</a><br />
 <a href="http://www.glc.us.es/">Grupo de Lógica Computacional</a><br />
 <a href="http://www.cs.us.es">Dpto. de Ciencias de la Computación e I.A.</a><br />
 <a href="http://www.us.es">Universidad de Sevilla</a></p>
</div>
</body>
</html>
